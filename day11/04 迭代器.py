# 获取一个对象的所以方法
# s1 = 'asjbjas'
# print(dir(s1))
# print('__dir__' in dir(s1))

# 迭代对象小结：(比较直观,存储数据相对少[几百万个对象,8G内存是可以承受的]的一个数据集)
# 字面意思：可以进行循环更新的一个实实在在的值
# 专业角度： 内部含有__iter__方法的对象，叫做可迭代对象
# 判断一个对象是不是可迭代对象：'__iter__' in dir(对象)
# str list tuple dict set range 文件句柄
# 优点：
#   1.存储的数据直接能显示，比较直观
#   2.拥有的方法比较多，操作方便
# 缺点：
#   1.占用内存
#   2.不能直接通过for循环,不能直接取值(索引,key除外)[其实for循环在底层做了一个小小的转化，就是先将可迭代对象转化成迭代器，然后在进行取值的]
#
#    应用：当你侧重于对于数据可以灵活处理，并且内存空间足够，将数据集设置为可迭代对象是明确的选择。


# 迭代器小结:
# 字面意思: 是一个可以迭代取值的工具，器：在这里当做工具比较合适
# 专业角度: 内部含有'__iter__'方法并且含有'__next__'方法的迭代对象就是迭代器
# 判断是否是迭代器: '__iter__'and'__next__' in dir(对象)
# 文件句柄
# 优点:
#   1.节省内存
#   2.惰性机制:next一次，取一个值，绝不过多取值
# 缺点:
#   1.速度相对慢
#   2.取值时不走回头路，只能一直向下取值(迭代器:(就一个next()取值方法)记录上次取值的位置)
# 应用：当你的数据量过大，大到足以撑爆你的内存或者你以节省内存为首选因素时，将数据集设置为迭代器是一个不错的选择。（可参考为什么python把文件句柄设置成迭代器）

# with open('哈哈', mode='w', encoding='utf-8') as f1:
#     f1.write('哈哈哈哈哈')
#
# print('__iter__' in dir(f1) and '__next__' in dir(f1))

# 可迭代对象可以转化成迭代器
# s1 = 'asj'
# obj = iter(s1)    # s1.__iter__()    形成迭代器
# print(obj)
# print(next(obj))    # obj.__next__()
# print(next(obj))
# print(next(obj))
# print(next(obj))    # StopIteration


# 可迭代对象(比如列表) 每次从头开始

# 迭代器:(就一个next()取值方法)记录上次取值的位置
# l1 = [11,22,33,44,55,66,77,88,99,113,25]
# obj = iter(l1)
# for i in range(4):
#     print(next(obj))
#
# for i in range(5):
#     print(next(obj))



# 面试题: 利用while循环模仿for循环对可迭代对象进行取值的机制(利用迭代器)
# 将可迭代对象转化成迭代器
# l1 = [11,22,33,44,55,66,77,88,99,113,25]
# obj = iter(l1)
# while True:
#     try:
#         print(next(obj))
#     except StopIteration:
#         break

# 今日总结:
# 默认参数的坑,作用域的坑 ***
# 格式化输出 ***
# 函数名的应用 ***
# 对比:迭代器是什么?迭代器的有缺点,可迭代对象转化迭代器,next()取值 ***

